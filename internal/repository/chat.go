package repository

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/messenger/internal/logger"
	"github.com/messenger/internal/model"
)

type ChatRepository struct {
	pool *pgxpool.Pool
}

func NewChatRepository(pool *pgxpool.Pool) *ChatRepository {
	return &ChatRepository{pool: pool}
}

func (r *ChatRepository) Create(ctx context.Context, c *model.Chat) error {
	defer logger.DeferLogDuration("chat.Create", time.Now())()
	_, err := r.pool.Exec(ctx,
		`INSERT INTO chats (id, chat_type, name, description, avatar_url, created_by, created_at)
		 VALUES ($1, $2, $3, $4, $5, $6, $7)`,
		c.ID, c.ChatType, c.Name, c.Description, c.AvatarURL, c.CreatedBy, c.CreatedAt,
	)
	if err != nil {
		return fmt.Errorf("chatRepo.Create: %w", err)
	}
	return nil
}

func (r *ChatRepository) GetByID(ctx context.Context, id string) (*model.Chat, error) {
	defer logger.DeferLogDuration("chat.GetByID", time.Now())()
	c := &model.Chat{}
	err := r.pool.QueryRow(ctx,
		`SELECT id, chat_type, name, COALESCE(description,''), avatar_url, created_by, created_at
		 FROM chats WHERE id = $1`, id,
	).Scan(&c.ID, &c.ChatType, &c.Name, &c.Description, &c.AvatarURL, &c.CreatedBy, &c.CreatedAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("chatRepo.GetByID: %w", err)
	}
	return c, nil
}

func (r *ChatRepository) UpdateChat(ctx context.Context, id, name, description, avatarURL string) error {
	defer logger.DeferLogDuration("chat.UpdateChat", time.Now())()
	_, err := r.pool.Exec(ctx,
		`UPDATE chats SET name = $1, description = $2, avatar_url = $3 WHERE id = $4`,
		name, description, avatarURL, id,
	)
	if err != nil {
		return fmt.Errorf("chatRepo.UpdateChat: %w", err)
	}
	return nil
}

func (r *ChatRepository) AddMember(ctx context.Context, m *model.ChatMember) error {
	defer logger.DeferLogDuration("chat.AddMember", time.Now())()
	_, err := r.pool.Exec(ctx,
		`INSERT INTO chat_members (chat_id, user_id, role, joined_at)
		 VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING`,
		m.ChatID, m.UserID, m.Role, m.JoinedAt,
	)
	if err != nil {
		return fmt.Errorf("chatRepo.AddMember: %w", err)
	}
	return nil
}

func (r *ChatRepository) RemoveMember(ctx context.Context, chatID, userID string) error {
	defer logger.DeferLogDuration("chat.RemoveMember", time.Now())()
	_, err := r.pool.Exec(ctx,
		`DELETE FROM chat_members WHERE chat_id = $1 AND user_id = $2`,
		chatID, userID,
	)
	if err != nil {
		return fmt.Errorf("chatRepo.RemoveMember: %w", err)
	}
	return nil
}

func (r *ChatRepository) GetMembers(ctx context.Context, chatID string) ([]model.User, error) {
	defer logger.DeferLogDuration("chat.GetMembers", time.Now())()
	rows, err := r.pool.Query(ctx,
		`SELECT u.id, u.username, u.email, u.password_hash, u.avatar_url, u.last_seen_at, u.is_online, u.created_at
		 FROM users u
		 JOIN chat_members cm ON cm.user_id = u.id
		 WHERE cm.chat_id = $1
		 ORDER BY cm.joined_at`, chatID,
	)
	if err != nil {
		return nil, fmt.Errorf("chatRepo.GetMembers query: %w", err)
	}
	defer rows.Close()

	users := make([]model.User, 0, 8)
	for rows.Next() {
		var u model.User
		if err := rows.Scan(&u.ID, &u.Username, &u.Email, &u.PasswordHash, &u.AvatarURL, &u.LastSeenAt, &u.IsOnline, &u.CreatedAt); err != nil {
			return nil, fmt.Errorf("chatRepo.GetMembers scan: %w", err)
		}
		users = append(users, u)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("chatRepo.GetMembers rows: %w", err)
	}
	return users, nil
}

func (r *ChatRepository) GetMemberIDs(ctx context.Context, chatID string) ([]string, error) {
	defer logger.DeferLogDuration("chat.GetMemberIDs", time.Now())()
	rows, err := r.pool.Query(ctx,
		`SELECT user_id FROM chat_members WHERE chat_id = $1`, chatID,
	)
	if err != nil {
		return nil, fmt.Errorf("chatRepo.GetMemberIDs query: %w", err)
	}
	defer rows.Close()

	ids := make([]string, 0, 8)
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, fmt.Errorf("chatRepo.GetMemberIDs scan: %w", err)
		}
		ids = append(ids, id)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("chatRepo.GetMemberIDs rows: %w", err)
	}
	return ids, nil
}

func (r *ChatRepository) IsMember(ctx context.Context, chatID, userID string) (bool, error) {
	defer logger.DeferLogDuration("chat.IsMember", time.Now())()
	var exists bool
	err := r.pool.QueryRow(ctx,
		`SELECT EXISTS(SELECT 1 FROM chat_members WHERE chat_id = $1 AND user_id = $2)`,
		chatID, userID,
	).Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("chatRepo.IsMember: %w", err)
	}
	return exists, nil
}

func (r *ChatRepository) GetMemberRole(ctx context.Context, chatID, userID string) (string, error) {
	defer logger.DeferLogDuration("chat.GetMemberRole", time.Now())()
	var role string
	err := r.pool.QueryRow(ctx,
		`SELECT role FROM chat_members WHERE chat_id = $1 AND user_id = $2`,
		chatID, userID,
	).Scan(&role)
	if errors.Is(err, pgx.ErrNoRows) {
		return "", ErrNotFound
	}
	if err != nil {
		return "", fmt.Errorf("chatRepo.GetMemberRole: %w", err)
	}
	return role, nil
}

func (r *ChatRepository) GetUserChats(ctx context.Context, userID string) ([]model.Chat, error) {
	defer logger.DeferLogDuration("chat.GetUserChats", time.Now())()
	rows, err := r.pool.Query(ctx,
		`SELECT c.id, c.chat_type, c.name, COALESCE(c.description,''), c.avatar_url, c.created_by, c.created_at
		 FROM chats c
		 JOIN chat_members cm ON cm.chat_id = c.id
		 WHERE cm.user_id = $1
		 ORDER BY c.created_at DESC`, userID,
	)
	if err != nil {
		return nil, fmt.Errorf("chatRepo.GetUserChats query: %w", err)
	}
	defer rows.Close()

	chats := make([]model.Chat, 0, 16)
	for rows.Next() {
		var c model.Chat
		if err := rows.Scan(&c.ID, &c.ChatType, &c.Name, &c.Description, &c.AvatarURL, &c.CreatedBy, &c.CreatedAt); err != nil {
			return nil, fmt.Errorf("chatRepo.GetUserChats scan: %w", err)
		}
		chats = append(chats, c)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("chatRepo.GetUserChats rows: %w", err)
	}
	return chats, nil
}

func (r *ChatRepository) FindPersonalChat(ctx context.Context, userID1, userID2 string) (*model.Chat, error) {
	defer logger.DeferLogDuration("chat.FindPersonalChat", time.Now())()
	c := &model.Chat{}
	err := r.pool.QueryRow(ctx,
		`SELECT c.id, c.chat_type, c.name, COALESCE(c.description,''), c.avatar_url, c.created_by, c.created_at
		 FROM chats c
		 WHERE c.chat_type = 'personal'
		   AND EXISTS (SELECT 1 FROM chat_members WHERE chat_id = c.id AND user_id = $1)
		   AND EXISTS (SELECT 1 FROM chat_members WHERE chat_id = c.id AND user_id = $2)`,
		userID1, userID2,
	).Scan(&c.ID, &c.ChatType, &c.Name, &c.Description, &c.AvatarURL, &c.CreatedBy, &c.CreatedAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("chatRepo.FindPersonalChat: %w", err)
	}
	return c, nil
}

// FindNotesChat returns the notes chat for the user (chat_type=notes, single member=userID).
func (r *ChatRepository) FindNotesChat(ctx context.Context, userID string) (*model.Chat, error) {
	defer logger.DeferLogDuration("chat.FindNotesChat", time.Now())()
	c := &model.Chat{}
	err := r.pool.QueryRow(ctx,
		`SELECT c.id, c.chat_type, c.name, COALESCE(c.description,''), c.avatar_url, c.created_by, c.created_at
		 FROM chats c
		 WHERE c.chat_type = 'notes'
		   AND EXISTS (SELECT 1 FROM chat_members WHERE chat_id = c.id AND user_id = $1)
		   AND (SELECT COUNT(*) FROM chat_members WHERE chat_id = c.id) = 1`,
		userID,
	).Scan(&c.ID, &c.ChatType, &c.Name, &c.Description, &c.AvatarURL, &c.CreatedBy, &c.CreatedAt)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("chatRepo.FindNotesChat: %w", err)
	}
	return c, nil
}

// NotesChatName is the display name for the system notes chat.
const NotesChatName = "Заметки"

// NotesChatDescription is the text shown in the notes chat.
const NotesChatDescription = "Это чат для личных заметок. Здесь удобно хранить:\n— планы на день;\n— список покупок;\n— полезные ссылки;\n— мысли и идеи.\n\nЭто ваш личный чат, в него нельзя добавлять других людей. Но при желании вы можете пересылать сообщения из заметок в другие чаты."

// GetOrCreateNotesChat returns the user's notes chat, creating it if it does not exist.
func (r *ChatRepository) GetOrCreateNotesChat(ctx context.Context, userID string) (*model.Chat, error) {
	defer logger.DeferLogDuration("chat.GetOrCreateNotesChat", time.Now())()
	c, err := r.FindNotesChat(ctx, userID)
	if err == nil {
		return c, nil
	}
	if !errors.Is(err, ErrNotFound) {
		return nil, err
	}
	c = &model.Chat{
		ID:          uuid.New().String(),
		ChatType:    model.ChatTypeNotes,
		Name:        NotesChatName,
		Description: NotesChatDescription,
		CreatedBy:   userID,
		CreatedAt:   time.Now(),
	}
	if err := r.Create(ctx, c); err != nil {
		return nil, err
	}
	member := &model.ChatMember{
		ChatID:   c.ID,
		UserID:   userID,
		Role:     "admin",
		JoinedAt: time.Now(),
	}
	if err := r.AddMember(ctx, member); err != nil {
		return nil, err
	}
	return c, nil
}

// UpdateMemberLastRead updates the last_read_at timestamp for a member.
func (r *ChatRepository) UpdateMemberLastRead(ctx context.Context, chatID, userID string, t time.Time) error {
	defer logger.DeferLogDuration("chat.UpdateMemberLastRead", time.Now())()
	_, err := r.pool.Exec(ctx,
		`UPDATE chat_members SET last_read_at = $1 WHERE chat_id = $2 AND user_id = $3`,
		t, chatID, userID,
	)
	if err != nil {
		return fmt.Errorf("chatRepo.UpdateMemberLastRead: %w", err)
	}
	return nil
}

// GetUnreadCount counts messages in a chat created after the user's last_read_at.
func (r *ChatRepository) GetUnreadCount(ctx context.Context, chatID, userID string) (int, error) {
	defer logger.DeferLogDuration("chat.GetUnreadCount", time.Now())()
	var count int
	err := r.pool.QueryRow(ctx,
		`SELECT COUNT(*) FROM messages m
		 JOIN chat_members cm ON cm.chat_id = m.chat_id AND cm.user_id = $2
		 WHERE m.chat_id = $1 AND m.sender_id != $2 AND m.created_at > cm.last_read_at AND m.is_deleted = false`,
		chatID, userID,
	).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("chatRepo.GetUnreadCount: %w", err)
	}
	return count, nil
}
